// Generated by CoffeeScript 1.8.0
(function() {
  var ExpressionUtils, KeymapUtils, MultiSelect, multiSelectDirective, queryFilter, queryParser,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  angular.module('akop', ['akop-multi-select', 'akop-keymap', 'akop-query-filter']);

  angular.module('akop-keymap', []).config([
    '$provide', function($provide) {
      return $provide.constant('KEYCODES', {
        'backspace': 8,
        'tab': 9,
        'enter': 13,
        'shift': 16,
        'ctrl': 17,
        'alt': 18,
        'pause_break': 19,
        'caps': 20,
        'esc': 27,
        'space': 32,
        'pageUp': 33,
        'pageDown': 34,
        'end': 35,
        'home': 36,
        'left': 37,
        'up': 38,
        'right': 39,
        'down': 40,
        'insert': 45,
        'delete': 46,
        '0': 48,
        '1': 49,
        '2': 50,
        '3': 51,
        '4': 52,
        '5': 53,
        '6': 54,
        '7': 55,
        '8': 56,
        '9': 57,
        'a': 65,
        'b': 66,
        'c': 67,
        'd': 68,
        'e': 69,
        'f': 70,
        'g': 71,
        'h': 72,
        'i': 73,
        'j': 74,
        'k': 75,
        'l': 76,
        'm': 77,
        'n': 78,
        'o': 79,
        'p': 80,
        'q': 81,
        'r': 82,
        's': 83,
        't': 84,
        'u': 85,
        'v': 86,
        'w': 87,
        'x': 88,
        'y': 89,
        'z': 90,
        'left_window': 91,
        'right_window': 92,
        'select_key': 93,
        'numpad_0': 96,
        'numpad_1': 97,
        'numpad_2': 98,
        'numpad_3': 99,
        'numpad_4': 100,
        'numpad_5': 101,
        'numpad_6': 102,
        'numpad_7': 103,
        'numpad_8': 104,
        'numpad_9': 105,
        '*': 106,
        '+': 107,
        'minus': 109,
        'decimal_point': 110,
        '%': 111,
        'f1': 112,
        'f2': 113,
        'f3': 114,
        'f4': 115,
        'f5': 116,
        'f6': 117,
        'f7': 118,
        'f8': 119,
        'f9': 120,
        'f10': 121,
        'f11': 122,
        'f12': 123,
        'num_lock': 144,
        'scroll_lock': 145,
        ';': 186,
        '=': 187,
        '': 188,
        '\-': 189,
        '.': 190,
        '/': 191,
        'grave_accent': 192,
        '{': 219,
        '\\': 220,
        '}': 221,
        '\'': 222
      });
    }
  ]);

  KeymapUtils = function(KEYCODES) {
    var codeFor, comboEventMatch, parseCombo, _arrayEqual, _eventKeys;
    _arrayEqual = function(a, b, enforce_order) {
      if (enforce_order == null) {
        enforce_order = true;
      }
      if (!enforce_order) {
        a.sort() && b.sort();
      }
      return a.length === b.length && a.every(function(elem, i) {
        return elem === b[i];
      });
    };
    _eventKeys = function(event) {
      var keys;
      keys = [];
      if (event.altKey) {
        keys.push(codeFor('alt'));
      }
      if (event.ctrlKey) {
        keys.push(codeFor('ctrl'));
      }
      if (event.shiftKey) {
        keys.push(codeFor('shift'));
      }
      keys.push(parseInt(event.keyCode));
      return keys;
    };
    codeFor = function(key) {
      return KEYCODES[key];
    };
    parseCombo = function(combo_string) {
      return _.map(combo_string.split('-'), function(key) {
        return codeFor(key);
      });
    };
    comboEventMatch = function(combo_string, event) {
      return _arrayEqual(_eventKeys(event), parseCombo(combo_string), false);
    };
    return {
      codeFor: codeFor,
      parseCombo: parseCombo,
      comboEventMatch: comboEventMatch
    };
  };

  KeymapUtils.$inject = ['KEYCODES'];

  angular.module('akop-keymap').service('KeymapUtils', KeymapUtils);

  angular.module('akop-multi-select', []);

  MultiSelect = (function() {
    function MultiSelect(list, root) {
      this.list = list;
      this.root = root;
      this.moveToNext = __bind(this.moveToNext, this);
      this.moveToPrev = __bind(this.moveToPrev, this);
      this.selectFirst = __bind(this.selectFirst, this);
      this.selectLast = __bind(this.selectLast, this);
      this.selectNext = __bind(this.selectNext, this);
      this.selectPrev = __bind(this.selectPrev, this);
      if (this.root) {
        this.reset(this.root);
      }
    }

    MultiSelect.prototype.reset = function(root) {
      this.root = root != null ? root : null;
      _.each(this.list, function(el) {
        el.selected = false;
      });
      this.selected = [];
      if (this.root) {
        this.include(this.root, false);
      }
      return this.selected;
    };

    MultiSelect.prototype.include = function(el, enforce_adjacency) {
      var pos;
      if (enforce_adjacency == null) {
        enforce_adjacency = true;
      }
      pos = this._pos(el);
      if (pos < 0) {
        throw new Error("MultiSelect: Element must be a member of list.");
      }
      if (enforce_adjacency && !this._isAdjacent(pos)) {
        return false;
      }
      el.selected = true;
      this.selected[pos] = el;
      this.cursor = pos;
      return this.selected;
    };

    MultiSelect.prototype.includeUntil = function(el) {
      var cursor, i, pos, _i;
      if (this.selected.length) {
        pos = this._pos(el);
        cursor = this.cursor;
        for (i = _i = pos; pos <= cursor ? _i <= cursor : _i >= cursor; i = pos <= cursor ? ++_i : --_i) {
          this.include(this.list[i], false);
        }
      } else {
        this.reset(el);
      }
      return this.selected;
    };

    MultiSelect.prototype.exclude = function(el, enforce_adjacency) {
      var is_lower, is_upper, pos;
      if (enforce_adjacency == null) {
        enforce_adjacency = true;
      }
      pos = this._pos(el);
      if (enforce_adjacency) {
        is_upper = this._is_upper(pos);
        is_lower = this._is_lower(pos);
        if (!(is_upper || is_lower)) {
          return false;
        }
        if (is_upper) {
          this.selected.pop();
          this.cursor = this._upper_index();
        } else {
          this.selected.splice(this._lower_index(), 1, void 0);
          this.cursor = this._lower_index();
        }
      } else {
        this.selected.splice(pos, 1, void 0);
        this.cursor = this._closest_selected_index(pos);
      }
      el.selected = false;
      return this.selected;
    };

    MultiSelect.prototype.moveCursorTo = function(index) {
      var el, step;
      if (index < 0 || index > this.list.length - 1) {
        return this.selected;
      }
      el = this.list[index];
      if (el.selected) {
        step = this._is_desc(index, this.cursor) ? 1 : -1;
        return this.exclude(this.list[index + step]);
      } else {
        return this.include(el);
      }
    };

    MultiSelect.prototype.selectPrev = function() {
      if ((this.cursor != null) === false || this.cursor === 0) {
        return this.reset(_.last(this.list));
      } else {
        return this.reset(this.list[this.cursor - 1]);
      }
    };

    MultiSelect.prototype.selectNext = function() {
      if ((this.cursor != null) === false || this.cursor === this.list.length - 1) {
        return this.reset(this.list[0]);
      } else {
        return this.reset(this.list[this.cursor + 1]);
      }
    };

    MultiSelect.prototype.selectLast = function() {
      return this.reset(_.last(this.list));
    };

    MultiSelect.prototype.selectFirst = function() {
      return this.reset(_.first(this.list));
    };

    MultiSelect.prototype.moveToPrev = function() {
      return this.moveCursorTo(this.cursor - 1);
    };

    MultiSelect.prototype.moveToNext = function() {
      return this.moveCursorTo(this.cursor + 1);
    };

    MultiSelect.prototype._closest_selected_index = function(idx, distance) {
      var high, low, nextSib, prevSib;
      if (distance == null) {
        distance = 1;
      }
      high = idx + distance;
      low = idx - distance;
      if (low < 0 && high > this.list.length - 1) {
        return false;
      }
      if (high <= this.list.length - 1) {
        nextSib = this.list[high];
        if (nextSib.selected) {
          return high;
        }
      }
      if (low >= 0) {
        prevSib = this.list[low];
        if (prevSib.selected) {
          return low;
        }
      }
      return this._closest_selected_index(idx, distance + 1);
    };

    MultiSelect.prototype._is_asc = function(current_idx, prev_idx) {
      return current_idx - prev_idx === 1;
    };

    MultiSelect.prototype._is_desc = function(current_idx, prev_idx) {
      return current_idx - prev_idx === -1;
    };

    MultiSelect.prototype._pos = function(el) {
      return this.list.indexOf(el);
    };

    MultiSelect.prototype._isAdjacent = function(pos) {
      return pos - 1 === this._upper_index() || pos + 1 === this._lower_index();
    };

    MultiSelect.prototype._upper_index = function() {
      return this.selected.length - 1;
    };

    MultiSelect.prototype._lower_index = function() {
      var occupied;
      occupied = _.filter(this.selected, function(el) {
        return el;
      });
      return this.selected.indexOf(_.first(occupied));
    };

    MultiSelect.prototype._is_upper = function(index) {
      return this._upper_index() === index;
    };

    MultiSelect.prototype._is_lower = function(index) {
      return this._lower_index() === index;
    };

    return MultiSelect;

  })();

  angular.module('akop-multi-select').factory('MultiSelect', function() {
    return MultiSelect;
  });

  multiSelectDirective = function(KeymapUtils, MultiSelect) {
    return {
      restrict: 'A',
      link: function($scope, el, attrs) {
        $scope.$watch(attrs['akopMultiSelect'], function(items) {
          return $scope.multiSelect = new MultiSelect(items || []);
        });
        $scope.$watch(attrs['selectableName'], function() {
          return $scope.selectableName = attrs.selectableName;
        });
        $scope.keymap = {
          'up': function() {
            return $scope.multiSelect.selectPrev();
          },
          'down': function() {
            return $scope.multiSelect.selectNext();
          },
          'shift-up': function() {
            return $scope.multiSelect.moveToPrev();
          },
          'shift-down': function() {
            return $scope.multiSelect.moveToNext();
          },
          'alt-down': function() {
            return $scope.multiSelect.selectLast();
          },
          'alt-up': function() {
            return $scope.multiSelect.selectFirst();
          },
          'esc': function() {
            return $scope.multiSelect.reset();
          }
        };
        el.bind('keydown', function(e) {
          return $scope.$apply(function() {
            var combo, funct, _ref, _results;
            if (e.shiftKey) {
              $(el).addClass('akop-noselect');
            }
            _ref = $scope.keymap;
            _results = [];
            for (combo in _ref) {
              funct = _ref[combo];
              if (KeymapUtils.comboEventMatch(combo, e)) {
                e.preventDefault();
                _results.push(funct.call());
              } else {
                _results.push(void 0);
              }
            }
            return _results;
          });
        });
        el.bind('keyup', function(e) {
          return $scope.$apply(function() {
            if (e.shiftKey) {
              return $(el).removeClass('akop-noselect');
            }
          });
        });
        return el.bind('click', function(e) {
          var item;
          item = angular.element(e.target).scope()[$scope.selectableName];
          return $scope.$apply(function() {
            if (e.shiftKey) {
              return $scope.multiSelect.includeUntil(item);
            } else if (e.metaKey) {
              if (item.selected) {
                return $scope.multiSelect.exclude(item, false);
              } else {
                return $scope.multiSelect.include(item, false);
              }
            } else {
              return $scope.multiSelect.reset(item);
            }
          });
        });
      }
    };
  };

  multiSelectDirective.$inject = ['KeymapUtils', 'MultiSelect'];

  angular.module('akop-multi-select').directive('akopMultiSelect', multiSelectDirective);

  angular.module('akop-query-filter', []);

  queryFilter = function($filter, parse, utils) {
    var flt;
    flt = function(exps, lst, filtered) {
      var matching, _ref;
      if (filtered == null) {
        filtered = [];
      }
      while (exps.length) {
        matching = $filter('filter')(lst, exps.pop(), true);
        filtered.push(matching);
        flt(exps, (_ref = _(lst)).without.apply(_ref, matching), filtered);
      }
      return _(filtered).flatten();
    };
    return function(list, expression) {
      var array_arguments, array_results, group_by, results;
      expression = parse(expression);
      group_by = expression.group_by;
      delete expression.group_by;
      array_arguments = utils.getArrayArguments(expression);
      array_results = flt(utils.arrayArgsToExpressions(expression), list);
      results = array_arguments.length > 0 ? flt([expression], array_results) : flt([expression], list);
      if (!group_by) {
        return results;
      }
      if (_.any(list, function(element) {
        return element[group_by] === void 0;
      })) {
        throw new Error("serviceQueryFilter: Missing group_by property \"" + group_by + "\" for some or all elements in list.");
      }
      return _.groupBy(results, group_by);
    };
  };

  queryFilter.$inject = ['$filter', 'akopParser', 'expressionUtils'];

  angular.module('akop-query-filter').filter('akopQuery', queryFilter);

  queryParser = function() {
    return function(query) {
      var expression, key, match, matches, pattern, strip, v, val, val_arr, vals, _i, _len;
      if (query === Object(query)) {
        return query;
      }
      if (!(query.split(":").length > 1)) {
        return query;
      }
      pattern = /(\w+):((\w+)|(\[.*\])|"(.*)")/g;
      matches = [];
      while (match = pattern.exec(query)) {
        matches.push(match);
      }
      strip = function(v) {
        return String(v).replace(/^[\s\"]+|[\s\"]+$/g, '');
      };
      expression = {};
      for (_i = 0, _len = matches.length; _i < _len; _i++) {
        match = matches[_i];
        key = match[1];
        val = match[5] || match[2];
        val_arr = val.match(/\[(.*)\]/);
        if (val_arr) {
          vals = val_arr[1].split(",");
          expression[key] = (function() {
            var _j, _len1, _results;
            _results = [];
            for (_j = 0, _len1 = vals.length; _j < _len1; _j++) {
              v = vals[_j];
              _results.push("" + (strip(v)));
            }
            return _results;
          })();
        } else {
          expression[key] = "" + val;
        }
      }
      return expression;
    };
  };

  angular.module('akop-query-filter').factory('akopParser', queryParser);

  ExpressionUtils = (function() {
    function ExpressionUtils() {}

    ExpressionUtils.prototype.getArrayArguments = function(expression) {
      var arg, attr;
      return _.compact((function() {
        var _results;
        _results = [];
        for (attr in expression) {
          arg = expression[attr];
          _results.push(_.isArray(arg) ? {
            attr: attr,
            arg: arg
          } : void 0);
        }
        return _results;
      })());
    };

    ExpressionUtils.prototype.arrayArgsToExpressions = function(expression) {
      var arg_obj, exp, expressions, val, _i, _j, _len, _len1, _ref, _ref1;
      expressions = [];
      _ref = this.getArrayArguments(expression);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        arg_obj = _ref[_i];
        _ref1 = arg_obj.arg;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          val = _ref1[_j];
          exp = {};
          exp[arg_obj.attr] = val;
          delete expression[arg_obj.attr];
          expressions.push(exp);
        }
      }
      return expressions;
    };

    return ExpressionUtils;

  })();

  angular.module('akop-query-filter').service('expressionUtils', ExpressionUtils);

}).call(this);
